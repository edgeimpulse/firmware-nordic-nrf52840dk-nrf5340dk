/* Generated by Edge Impulse
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
// Generated on: 12.01.2024 09:45:17

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#if defined __GNUC__
#define ALIGN(X) __attribute__((aligned(X)))
#elif defined _MSC_VER
#define ALIGN(X) __declspec(align(X))
#elif defined __TASKING__
#define ALIGN(X) __align(X)
#elif defined __ICCARM__
#define ALIGN(x) __attribute__((aligned(x)))
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#ifndef CONFIG_IDF_TARGET_ESP32S3
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#else
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#endif // CONFIG_IDF_TARGET_ESP32S3
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX) || defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
constexpr int kTensorArenaSize = 1584;
#else
constexpr int kTensorArenaSize = 560;
#endif

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};
enum used_operators_e {
  OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};
struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
};

typedef struct {
  TfLiteTensor tensor;
  int16_t index;
} TfLiteTensorWithIndex;

typedef struct {
  TfLiteEvalTensor tensor;
  int16_t index;
} TfLiteEvalTensorWithIndex;

TfLiteContext ctx{};
static const int MAX_TFL_TENSOR_COUNT = 4;
static TfLiteTensorWithIndex tflTensors[MAX_TFL_TENSOR_COUNT];
static const int MAX_TFL_EVAL_COUNT = 4;
static TfLiteEvalTensorWithIndex tflEvalTensors[MAX_TFL_EVAL_COUNT];
TfLiteRegistration registrations[OP_LAST];

const TfArray<2, int> tensor_dimension0 = { 2, { 1,39 } };
const ALIGN(16) float tensor_data1[10] = { 0.048503775149583817, 0.057994186878204346, -0.0078787412494421005, 0.04343317449092865, -0.068484142422676086, 0.21931768953800201, -0.0048790131695568562, -0.057461101561784744, -0.04473746195435524, -0.023811234161257744, };
const TfArray<1, int> tensor_dimension1 = { 1, { 10 } };
const ALIGN(16) float tensor_data2[20] = { 0.0087776556611061096, 0.16387671232223511, 0.0274981539696455, 0.19366089999675751, 0.01794513501226902, 0.0091804340481758118, -0.036167800426483154, 0.055555392056703568, 0.006282211747020483, 0.035195339471101761, 0.081801712512969971, 0.024284763261675835, 0.038529142737388611, 0.10676077008247375, 0.081735171377658844, 0.029754087328910828, -0.021513337269425392, 0.014822996221482754, -0.034045848995447159, 0.11809834837913513, };
const TfArray<1, int> tensor_dimension2 = { 1, { 20 } };
const ALIGN(16) float tensor_data3[4] = { -0.17700213193893433, 0.19672350585460663, 0.024777879938483238, -0.086556710302829742, };
const TfArray<1, int> tensor_dimension3 = { 1, { 4 } };
const ALIGN(16) float tensor_data4[20*39] = { 
  -0.13443391025066376, -0.090700484812259674, -0.042697392404079437, 0.27077522873878479, 0.10095895081758499, 0.16151301562786102, 0.066891305148601532, -0.23567824065685272, 0.075126767158508301, -0.28177675604820251, -0.023309711366891861, 0.081621207296848297, -0.30586212873458862, -0.18305766582489014, -0.23690952360630035, 0.24015094339847565, 0.088345848023891449, 0.23587577044963837, -0.061612192541360855, -0.074355639517307281, 0.32108768820762634, -0.043775025755167007, 0.28316044807434082, 0.10222905874252319, -0.26013076305389404, 0.22224074602127075, 0.026794081553816795, -0.022999921813607216, -0.32178029417991638, -0.26164016127586365, 0.10860928148031235, 0.22574944794178009, 0.29497811198234558, -0.18605311214923859, -0.22895540297031403, 0.20897176861763, -0.15637624263763428, 0.24287229776382446, 0.0020560023840516806, 
  -0.51711195707321167, 0.21562157571315765, 0.06156163290143013, 0.20272736251354218, 0.070531249046325684, 0.097005151212215424, -0.0003624571836553514, -0.094820044934749603, -0.09289957582950592, 0.070938393473625183, -0.44671913981437683, -0.10832539945840836, -0.19151616096496582, 0.18101523816585541, 0.086507216095924377, -0.28979271650314331, 0.40631529688835144, 0.31475189328193665, 0.53750044107437134, 0.10092967003583908, -0.080395832657814026, -0.15044668316841125, 0.13104259967803955, -0.11201991140842438, 0.07416331022977829, 0.099859505891799927, 0.061206452548503876, 0.44204422831535339, -0.047726869583129883, -0.080217979848384857, 0.086217999458312988, 0.44775429368019104, 0.34705203771591187, 0.29429739713668823, 0.27574840188026428, 0.036385823041200638, -0.20470568537712097, 0.03508966788649559, 0.23858773708343506, 
  0.35826277732849121, -0.28014981746673584, -0.20749670267105103, -0.19838909804821014, 0.15870045125484467, -0.088493891060352325, 0.28509560227394104, 0.35768479108810425, 0.3827979564666748, 0.053188506513834, -0.19316598773002625, 0.13009689748287201, -0.1398630291223526, 0.23333179950714111, -0.29923489689826965, 0.20731513202190399, 0.1232779398560524, 0.20019881427288055, -0.051632456481456757, 0.045536763966083527, 0.2517370879650116, -0.3419889509677887, 0.11250279098749161, -0.32252514362335205, -0.031671363860368729, -0.13089315593242645, 0.53072828054428101, 0.083116412162780762, -0.2945035994052887, -0.1953921765089035, -0.084030233323574066, 0.30182689428329468, 0.25834667682647705, -0.17777836322784424, -0.079767189919948578, -0.13761645555496216, -0.30660948157310486, -0.059796255081892014, 0.10692497342824936, 
  -0.19102339446544647, 0.52153903245925903, -0.40095424652099609, 0.38065069913864136, 0.16823779046535492, 0.3709433376789093, 0.099034078419208527, 0.36740419268608093, 0.058486990630626678, -0.32754978537559509, 0.048935472965240479, 0.086188420653343201, 0.040813341736793518, 0.33100497722625732, 0.31998264789581299, -0.11192980408668518, -0.043526783585548401, 0.045987140387296677, 0.29468008875846863, 0.31064853072166443, -0.32990783452987671, -0.038765139877796173, -0.34960520267486572, -0.26871654391288757, 0.016797326505184174, 0.087771698832511902, -0.4301115870475769, 0.25814899802207947, 0.34512695670127869, 0.38541722297668457, 0.021951219066977501, 0.16498389840126038, 0.069731295108795166, -0.34762093424797058, -0.0019475562730804086, -0.1494126170873642, 0.16410143673419952, -0.27805253863334656, 0.20980362594127655, 
  0.29260420799255371, 0.088185988366603851, 0.072448410093784332, -0.20142300426959991, -0.26083993911743164, -0.26634037494659424, 0.23173812031745911, -0.10894769430160522, -0.19023092091083527, 0.14620289206504822, -0.14374168217182159, 0.01733093149960041, -0.23415438830852509, -0.14627134799957275, -0.13794328272342682, 0.23498782515525818, 0.17787794768810272, 0.19327551126480103, -0.081711933016777039, -0.14825302362442017, -0.10591776669025421, 0.22271959483623505, -0.12170453369617462, -0.11882898211479187, -0.16680468618869781, -0.061730500310659409, 0.19726215302944183, 0.14398546516895294, -0.21787425875663757, -0.25077235698699951, 0.1329585462808609, -0.24825564026832581, 0.22797980904579163, -0.27324464917182922, -0.1635163426399231, -0.22160039842128754, -0.16222253441810608, -0.33905124664306641, 0.016436981037259102, 
  -0.23672160506248474, 0.041380804032087326, 0.08061198890209198, 0.013550194911658764, -0.06472652405500412, -0.20578598976135254, 0.057730846107006073, 0.33390724658966064, -0.10054390132427216, 0.088267363607883453, -0.26614835858345032, -0.093872435390949249, -0.28646880388259888, 0.22395090758800507, -0.13587220013141632, -0.046884313225746155, -0.25292679667472839, 0.13080260157585144, -0.024614166468381882, 0.087047383189201355, -0.196680948138237, -0.22134338319301605, -0.0096286134794354439, -0.11858426034450531, 0.25234818458557129, -0.056009385734796524, 0.30774912238121033, 0.10722500830888748, -0.29929313063621521, 0.36078721284866333, 0.029221292585134506, 0.086954392492771149, 0.354623943567276, -0.10265240073204041, 0.14181779325008392, -0.22287826240062714, 0.25736963748931885, -0.1580541729927063, 0.14805026352405548, 
  0.12020009756088257, -0.039008002728223801, -0.11915400624275208, -0.20925439894199371, -0.23144307732582092, -0.31139340996742249, -0.096386946737766266, 0.23651938140392303, -0.091442570090293884, 0.045710988342761993, 0.014837725088000298, -0.00098288035951554775, 0.022049415856599808, 0.14988785982131958, 0.094650939106941223, -0.079686366021633148, -0.16273637115955353, -0.19481536746025085, 0.33142250776290894, 0.27083402872085571, -0.12036936730146408, 0.091973945498466492, -0.11107664555311203, 0.23976615071296692, -0.091013282537460327, 0.0030330177396535873, 0.28767231106758118, -0.20513670146465302, 0.23787622153759003, 0.040770061314105988, 0.16884809732437134, -0.27127799391746521, 0.035260181874036789, -0.0027192384004592896, -0.21135900914669037, 0.22066344320774078, -0.24777804315090179, 0.16435360908508301, -0.22188732028007507, 
  0.18905831873416901, -0.098244212567806244, 0.0007105628028512001, 0.32550668716430664, 0.33186838030815125, 0.057263102382421494, 0.017027134075760841, 0.032983124256134033, -0.23102761805057526, 0.14079712331295013, -0.21442592144012451, 0.1656314879655838, -0.24866324663162231, 0.13269734382629395, -0.029069643467664719, -0.31169459223747253, -0.042986385524272919, -0.10314751416444778, -0.20750093460083008, 0.26820993423461914, 0.16723085939884186, -0.2812628448009491, -0.23129412531852722, -0.05479157343506813, -0.10935775935649872, 0.25241869688034058, -0.22995339334011078, 0.11880970746278763, -0.1484127938747406, -0.0073545165359973907, 0.090857848525047302, 0.23555302619934082, -0.081331372261047363, -0.43122896552085876, -0.2217458039522171, -0.40164905786514282, -0.12964130938053131, 0.11190187931060791, 0.3162667453289032, 
  0.13495072722434998, 0.35565611720085144, 0.15749830007553101, -0.044494010508060455, -0.26175671815872192, 0.16950048506259918, -0.080115102231502533, -0.23719598352909088, -0.10198704898357391, -0.12129522114992142, -0.039912521839141846, 0.11850451678037643, 0.10529707372188568, -0.11781194061040878, 0.13248984515666962, -0.17287357151508331, 0.13678765296936035, -0.13930265605449677, 0.29487326741218567, 0.018020473420619965, 0.24220222234725952, 0.20192304253578186, 0.26216655969619751, 0.13479310274124146, 0.23356109857559204, 0.27384072542190552, 0.22339189052581787, -0.026983940973877907, 0.30477514863014221, -0.28417065739631653, 0.14695954322814941, -0.31782969832420349, -0.020185833796858788, 0.07402462512254715, -0.17940287292003632, -0.0039548622444272041, -0.19416020810604095, 0.3309100866317749, -0.16409502923488617, 
  -0.34750911593437195, -0.039855360984802246, -0.24930651485919952, 0.029181554913520813, -0.13258260488510132, 0.24418927729129791, -0.24246092140674591, 0.033776536583900452, -0.13742451369762421, -0.28415337204933167, -0.23766340315341949, -0.18419747054576874, -0.2781561017036438, 0.0016838159644976258, -0.36163443326950073, 0.19227120280265808, 0.011499241925776005, 0.22713105380535126, 0.29730838537216187, -0.14399407804012299, -0.014713341370224953, 0.23360349237918854, 0.076642364263534546, 0.32702547311782837, 0.33914217352867126, 0.24640418589115143, 0.20180884003639221, 0.21400439739227295, -0.17291824519634247, 0.21394069492816925, -0.048372745513916016, 0.029392430558800697, -0.10813009738922119, 0.087733402848243713, 0.29966682195663452, 0.17895102500915527, 0.26819255948066711, 0.27562126517295837, -0.0084905494004487991, 
  0.27385547757148743, 0.14046315848827362, 0.16619883477687836, -0.23634244501590729, -0.21657592058181763, -0.22099022567272186, 0.083183936774730682, -0.044917568564414978, -0.1178155243396759, 0.0037474518176168203, -0.33831265568733215, -0.0034687360748648643, -0.013696662150323391, -0.21376112103462219, 0.21792897582054138, -0.079517781734466553, 0.042070891708135605, 0.0043288674205541611, 0.033449597656726837, -0.0067439386621117592, -0.34549421072006226, 0.079824298620223999, -0.362812340259552, 0.17087264358997345, 0.19225415587425232, -0.12484665960073471, -0.15657611191272736, -0.11592797189950943, 0.30811390280723572, 0.26691561937332153, -0.32069107890129089, -0.33440008759498596, -0.32220697402954102, -0.11343278735876083, 0.26448565721511841, 0.2148062139749527, -0.14947791397571564, -0.30786660313606262, -0.30311763286590576, 
  -0.070420384407043457, 0.17791421711444855, 0.25034710764884949, -0.06162194162607193, -0.19808554649353027, -0.27991822361946106, 0.2979314923286438, -0.15012381970882416, 0.18987354636192322, -0.1075756624341011, 0.23700909316539764, 0.25119149684906006, 0.16019527614116669, 0.32917213439941406, -0.01919502392411232, 0.13348852097988129, -0.094778880476951599, -0.061233341693878174, 0.30356806516647339, 0.012741074897348881, -0.073360517621040344, -0.076675325632095337, 0.29544532299041748, 0.028529785573482513, 0.11202915757894516, 0.15648050606250763, 0.25389686226844788, 0.19337289035320282, 0.37115538120269775, 0.13240191340446472, -0.035578198730945587, -0.048781562596559525, 0.039134182035923004, -0.0013767522759735584, 0.1853337436914444, 0.013178953900933266, -0.13183031976222992, 0.16033370792865753, 0.16393925249576569, 
  -0.18906767666339874, -0.27190342545509338, 0.038084737956523895, -0.07042115181684494, 0.18473494052886963, -0.31715497374534607, -0.2324514240026474, -0.35028934478759766, -0.29796415567398071, 0.10890918225049973, -0.11500802636146545, -0.33544182777404785, 0.035632245242595673, 0.13993430137634277, -0.06959601491689682, 0.27463188767433167, 0.062119603157043457, -0.16328775882720947, 0.21921887993812561, -0.12861882150173187, 0.10607066750526428, 0.13552106916904449, -0.23974762856960297, 0.15507791936397552, 0.11553885787725449, -0.14295901358127594, -0.0013542225351557136, -0.15572616457939148, 0.28215375542640686, -0.046121925115585327, -0.1284831315279007, 0.030572749674320221, -0.34994611144065857, 0.24012069404125214, 0.15106144547462463, 0.15118539333343506, 0.21051262319087982, -0.25297814607620239, -0.31229791045188904, 
  0.19938625395298004, -0.062126230448484421, -0.3356042206287384, 0.091347701847553253, 0.38952445983886719, 0.3502674400806427, -0.2419985830783844, 0.3032715916633606, -0.070226907730102539, 0.056275952607393265, -0.010002200491726398, 0.040785063058137894, 0.24240550398826599, 0.14706403017044067, 0.13950622081756592, -0.16443632543087006, -0.20581734180450439, 0.058503206819295883, -0.27585276961326599, -0.14916905760765076, -0.29968169331550598, -0.32665202021598816, -0.063496731221675873, -0.17489024996757507, -0.1846688985824585, -0.36465942859649658, -0.4547761082649231, 0.1514834463596344, 0.14220082759857178, 0.11077121645212173, 0.15534287691116333, -0.41662919521331787, -0.37969997525215149, -0.4330214262008667, -0.14067624509334564, -0.013336470350623131, 0.087611481547355652, -0.025099782273173332, 0.29148098826408386, 
  0.48924502730369568, -0.43197000026702881, -0.1757226288318634, 0.154878169298172, 0.11594262719154358, -0.16643093526363373, -0.12687471508979797, 0.11622657626867294, 0.14367501437664032, 0.10208937525749207, 0.27892574667930603, -0.3242594301700592, -0.27412638068199158, 0.42229554057121277, -0.23884280025959015, -0.080175638198852539, -0.19186264276504517, 0.12351537495851517, 0.13708557188510895, -0.31376135349273682, 0.20351722836494446, 0.23908524215221405, -0.22343209385871887, 0.14750203490257263, -0.36743900179862976, -0.24692094326019287, 0.048607811331748962, -0.36559367179870605, 0.20703171193599701, 0.0098820226266980171, 0.43047505617141724, -0.17802122235298157, -0.16378803551197052, 0.17362974584102631, -0.099105760455131531, -0.26436081528663635, -0.29896396398544312, 0.040565799921751022, 0.21413111686706543, 
  0.33456692099571228, -0.054896712303161621, -0.17903350293636322, -0.2421506941318512, -0.2494281679391861, 0.11405660957098007, 0.019570713862776756, 0.11618445068597794, 0.17374074459075928, 0.16013003885746002, 0.034595612436532974, 0.1861368715763092, -0.10954307019710541, 0.28046515583992004, 0.24962951242923737, 0.24325522780418396, 0.077779293060302734, 0.14542679488658905, -0.0053600757382810116, 0.013688898645341396, -0.38760015368461609, 0.2047540694475174, -0.32033932209014893, 0.021871400997042656, -0.00075301271863281727, -0.016673052683472633, 0.027611719444394112, -0.31827467679977417, -0.041092641651630402, -0.11888064444065094, 0.15614818036556244, -0.13213615119457245, -0.083025127649307251, 0.25120401382446289, -0.018352016806602478, 0.01307207252830267, 0.021888028830289841, -0.22141937911510468, 0.079889290034770966, 
  -0.14049147069454193, -0.1604374498128891, -0.15512402355670929, 0.0060480339452624321, 0.29667261242866516, -0.040868896991014481, -0.074731782078742981, -0.19913601875305176, 0.14458775520324707, -0.24914267659187317, -0.24586945772171021, -0.071346797049045563, 0.10180924087762833, 0.18216080963611603, -0.15986466407775879, 0.081292532384395599, -0.21351227164268494, -0.11346766352653503, 0.18097436428070068, -0.057586591690778732, -0.22402788698673248, -0.14264288544654846, 0.1585204005241394, -0.090568609535694122, 0.17341972887516022, -0.062842831015586853, -0.0094113368541002274, 0.30592462420463562, -0.25575700402259827, 0.24207852780818939, 0.14828872680664062, 0.039382316172122955, 0.28499922156333923, -0.15268170833587646, -0.054235298186540604, -0.12525628507137299, 0.13387174904346466, -0.2322031557559967, -0.097764424979686737, 
  -0.044722020626068115, 0.24150104820728302, 0.28880429267883301, 0.23487226665019989, 0.23996616899967194, -0.1026068851351738, -0.13957275450229645, 0.23697705566883087, 0.080989278852939606, -0.071503259241580963, -0.14091852307319641, 0.27977442741394043, -0.14936210215091705, 0.22096657752990723, -0.16522032022476196, -0.081524476408958435, -0.21025605499744415, 0.091100730001926422, 0.2773769199848175, -0.19563771784305573, 0.12785038352012634, -0.1757836788892746, -0.25811177492141724, 0.28821521997451782, -0.1941789835691452, -0.29466959834098816, -0.1954730898141861, 0.092467956244945526, -0.0060956096276640892, -0.17403985559940338, -0.036766801029443741, -0.26308095455169678, -0.029280660673975945, 0.029366783797740936, -0.024877825751900673, 0.26312986016273499, 0.25609496235847473, -0.19165931642055511, 0.2114318460226059, 
  -0.30020222067832947, -0.10023815929889679, 0.14318577945232391, -0.3405863344669342, 0.17668725550174713, 0.061025418341159821, -0.1719304621219635, 0.0043850014917552471, 0.02532489225268364, -0.077312357723712921, -0.25865599513053894, -0.086887970566749573, -0.23623037338256836, -0.25788530707359314, -0.25681716203689575, -0.20002530515193939, -0.012319501489400864, -0.16386507451534271, -0.13959336280822754, 0.15556839108467102, -0.12384812533855438, 0.29697608947753906, -0.13875478506088257, 0.28293070197105408, -0.10327941179275513, -0.2418544739484787, -0.046018581837415695, -0.071021229028701782, -0.31109234690666199, -0.2554040253162384, 0.15209552645683289, -0.10304943472146988, -0.16692446172237396, -0.25179755687713623, 0.3463464081287384, 0.28441795706748962, 0.12206727266311646, -0.17910045385360718, -0.20990215241909027, 
  -0.065715648233890533, 0.27256974577903748, 0.055631097406148911, -0.067805729806423187, -0.069012545049190521, -0.25669342279434204, -0.053773447871208191, -0.1945386528968811, 0.071047224104404449, 0.060837965458631516, -0.40853464603424072, 0.091445006430149078, 0.067870460450649261, -0.017705958336591721, 0.098026454448699951, 0.053059231489896774, 0.011459879577159882, -0.3723602294921875, -0.30011820793151855, -0.04626946896314621, -0.24567750096321106, -0.42037713527679443, 0.12486971169710159, -0.37240299582481384, -0.1518217921257019, -0.12826165556907654, -0.24030528962612152, -0.14465661346912384, 0.17848677933216095, 0.37556201219558716, -0.18253374099731445, -0.10413916409015656, 0.12946659326553345, -0.3244270384311676, -0.10675492882728577, -0.026183445006608963, -0.42022401094436646, -0.063313119113445282, -0.12367802858352661, 
};
const TfArray<2, int> tensor_dimension4 = { 2, { 20,39 } };
const ALIGN(16) float tensor_data5[10*20] = { 
  0.22920677065849304, 0.089492946863174438, -0.35017162561416626, 0.34548059105873108, 0.38663268089294434, 0.094837315380573273, 0.45353838801383972, -0.45717871189117432, 0.024298569187521935, -0.15583376586437225, 0.19939304888248444, 0.098507195711135864, 0.29248851537704468, 0.38632744550704956, 0.13715106248855591, -0.35595884919166565, 0.038967892527580261, 0.056546967476606369, -0.24833312630653381, 0.33198583126068115, 
  -0.28625524044036865, -0.7546953558921814, 0.43183809518814087, 0.09529384970664978, 0.35318091511726379, -0.21138590574264526, -0.17843206226825714, -0.24423117935657501, -0.44401189684867859, 0.016565054655075073, -0.1842227429151535, -0.24015834927558899, 0.29355081915855408, 0.23258939385414124, 0.44264194369316101, 0.68058681488037109, -0.16812874376773834, -0.046656552702188492, -0.13711294531822205, 0.10585473477840424, 
  -0.095035165548324585, -0.34157752990722656, -0.018541570752859116, 0.3991037905216217, -0.19443346560001373, -0.22820939123630524, -0.14069445431232452, 0.073591150343418121, -0.16069422662258148, -0.042010601609945297, 0.11945519596338272, 0.18996454775333405, -0.084715209901332855, -0.34164971113204956, -0.059661801904439926, -0.26666605472564697, 0.31583750247955322, -0.37044861912727356, -0.38322222232818604, -0.30915829539299011, 
  0.3228304386138916, 0.2650071382522583, 0.46495315432548523, -0.033297974616289139, -0.23712064325809479, 0.49346870183944702, -0.2088189423084259, -0.1510041356086731, -0.021061772480607033, 0.47388568520545959, 0.43007111549377441, 0.20232796669006348, -0.26020693778991699, -0.55219393968582153, -0.037837609648704529, -0.2723889946937561, -0.0027054538950324059, -0.25003111362457275, 0.42211344838142395, 0.49293592572212219, 
  -0.20889851450920105, 0.11379628628492355, -0.43849149346351624, -0.22471128404140472, -0.21562843024730682, 0.26153254508972168, -0.1437876969575882, 0.044195551425218582, -0.40356579422950745, 0.18406155705451965, 0.3807310163974762, 0.21835900843143463, -0.05746561661362648, 0.12954141199588776, 0.017705796286463737, -0.23377123475074768, -0.19413545727729797, 0.35802161693572998, 0.29850435256958008, 0.46447595953941345, 
  -0.090433426201343536, 0.5568007230758667, -0.10287836194038391, 0.59750884771347046, -0.20253206789493561, -0.31005874276161194, 0.034077152609825134, 0.51599156856536865, -0.3250051736831665, -0.014324328862130642, 0.26911550760269165, 0.38256597518920898, -0.22873817384243011, 0.48031747341156006, 0.10992604494094849, -0.15049801766872406, 0.069816112518310547, 0.59634602069854736, -0.4685204029083252, -0.21750456094741821, 
  0.35247591137886047, 0.36860615015029907, -0.13026620447635651, -0.17452619969844818, 0.26954606175422668, 0.30524167418479919, 0.022304711863398552, -0.087869323790073395, -0.066849827766418457, 0.016974454745650291, 0.19926366209983826, 0.1422770619392395, -0.3084159791469574, -0.27598312497138977, 0.017978539690375328, -0.10353927314281464, 0.2160695493221283, -0.09602230042219162, -0.08330971747636795, -0.21313323080539703, 
  -0.10286637395620346, 0.22016407549381256, 0.098997458815574646, 0.16503001749515533, -0.088777326047420502, 0.28532260656356812, 0.31280088424682617, -0.51337248086929321, 0.4728887677192688, -0.15666066110134125, -0.29304185509681702, 0.41771739721298218, 0.21079719066619873, -0.18449881672859192, -0.46921759843826294, 0.15159952640533447, 0.28297260403633118, -0.0093011660501360893, 0.029716931283473969, 0.14453178644180298, 
  0.18975263833999634, 0.05163269117474556, 0.14562702178955078, -0.01889432780444622, 0.38771182298660278, 0.11961587518453598, -0.390240877866745, -0.15265920758247375, -0.015438023023307323, 0.027370098978281021, 0.47970694303512573, 0.098304003477096558, 0.036509834229946136, -0.27901726961135864, -0.17152382433414459, 0.41103482246398926, -0.33826172351837158, 0.27629208564758301, -0.15929651260375977, 0.11304128915071487, 
  0.17400385439395905, -0.29770168662071228, -0.10465665906667709, -0.033043261617422104, 0.34162819385528564, 0.41036823391914368, -0.059634719043970108, 0.00051914469804614782, 0.27040818333625793, -0.33095601201057434, -0.13986165821552277, 0.20203064382076263, -0.24170681834220886, -0.25073012709617615, 0.16911368072032928, -0.036947939544916153, -0.056022223085165024, 0.35882082581520081, 0.030961669981479645, 0.5275123119354248, 
};
const TfArray<2, int> tensor_dimension5 = { 2, { 10,20 } };
const ALIGN(16) float tensor_data6[4*10] = { 
  0.42568257451057434, 0.21689121425151825, 0.62202674150466919, -0.34345731139183044, 0.1283877044916153, -0.90284132957458496, -0.64066648483276367, -0.097636252641677856, 0.69285041093826294, 0.33031055331230164, 
  0.36726826429367065, -0.33120575547218323, -0.51644015312194824, -0.86711412668228149, -0.56777346134185791, -0.14269065856933594, -0.011522313579916954, 0.13641832768917084, -0.29727107286453247, 0.041093993932008743, 
  -0.60608333349227905, 0.83423334360122681, -0.43140301108360291, -0.7401389479637146, 0.40255194902420044, -0.65221947431564331, 0.50030672550201416, 0.30618646740913391, 0.29884260892868042, -0.37139031291007996, 
  -0.056170325726270676, -0.33901789784431458, 0.017490893602371216, 0.51529771089553833, 0.15810355544090271, -0.63377177715301514, 0.6886487603187561, -0.18943388760089874, -0.48573926091194153, -0.62867105007171631, 
};
const TfArray<2, int> tensor_dimension6 = { 2, { 4,10 } };
const TfArray<2, int> tensor_dimension7 = { 2, { 1,20 } };
const TfArray<2, int> tensor_dimension8 = { 2, { 1,10 } };
const TfArray<2, int> tensor_dimension9 = { 2, { 1,4 } };
const TfArray<2, int> tensor_dimension10 = { 2, { 1,4 } };
const TfLiteFullyConnectedParams opdata0 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs0 = { 3, { 0,4,2 } };
const TfArray<1, int> outputs0 = { 1, { 7 } };
const TfLiteFullyConnectedParams opdata1 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs1 = { 3, { 7,5,1 } };
const TfArray<1, int> outputs1 = { 1, { 8 } };
const TfLiteFullyConnectedParams opdata2 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs2 = { 3, { 8,6,3 } };
const TfArray<1, int> outputs2 = { 1, { 9 } };
const TfLiteSoftmaxParams opdata3 = { 1 };
const TfArray<1, int> inputs3 = { 1, { 9 } };
const TfArray<1, int> outputs3 = { 1, { 10 } };
const TensorInfo_t tensorData[] = {
  { kTfLiteArenaRw, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension0, 156, },
  { kTfLiteMmapRo, (void*)tensor_data1, (TfLiteIntArray*)&tensor_dimension1, 40, },
  { kTfLiteMmapRo, (void*)tensor_data2, (TfLiteIntArray*)&tensor_dimension2, 80, },
  { kTfLiteMmapRo, (void*)tensor_data3, (TfLiteIntArray*)&tensor_dimension3, 16, },
  { kTfLiteMmapRo, (void*)tensor_data4, (TfLiteIntArray*)&tensor_dimension4, 3120, },
  { kTfLiteMmapRo, (void*)tensor_data5, (TfLiteIntArray*)&tensor_dimension5, 800, },
  { kTfLiteMmapRo, (void*)tensor_data6, (TfLiteIntArray*)&tensor_dimension6, 160, },
  { kTfLiteArenaRw, tensor_arena + 160, (TfLiteIntArray*)&tensor_dimension7, 80, },
  { kTfLiteArenaRw, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension8, 40, },
  { kTfLiteArenaRw, tensor_arena + 48, (TfLiteIntArray*)&tensor_dimension9, 16, },
  { kTfLiteArenaRw, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension10, 16, },
};
#ifndef TF_LITE_STATIC_MEMORY
TfLiteNode tflNodes[4] = {
  { (TfLiteIntArray*)&inputs0, (TfLiteIntArray*)&outputs0, (TfLiteIntArray*)&inputs0, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&opdata0)), nullptr, 0, },
  { (TfLiteIntArray*)&inputs1, (TfLiteIntArray*)&outputs1, (TfLiteIntArray*)&inputs1, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&opdata1)), nullptr, 0, },
  { (TfLiteIntArray*)&inputs2, (TfLiteIntArray*)&outputs2, (TfLiteIntArray*)&inputs2, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&opdata2)), nullptr, 0, },
  { (TfLiteIntArray*)&inputs3, (TfLiteIntArray*)&outputs3, (TfLiteIntArray*)&inputs3, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&opdata3)), nullptr, 0, },
};
#else
TfLiteNode tflNodes[4] = {
  { (TfLiteIntArray*)&inputs0, (TfLiteIntArray*)&outputs0, (TfLiteIntArray*)&inputs0, nullptr, const_cast<void*>(static_cast<const void*>(&opdata0)), nullptr, 0, },
  { (TfLiteIntArray*)&inputs1, (TfLiteIntArray*)&outputs1, (TfLiteIntArray*)&inputs1, nullptr, const_cast<void*>(static_cast<const void*>(&opdata1)), nullptr, 0, },
  { (TfLiteIntArray*)&inputs2, (TfLiteIntArray*)&outputs2, (TfLiteIntArray*)&inputs2, nullptr, const_cast<void*>(static_cast<const void*>(&opdata2)), nullptr, 0, },
  { (TfLiteIntArray*)&inputs3, (TfLiteIntArray*)&outputs3, (TfLiteIntArray*)&inputs3, nullptr, const_cast<void*>(static_cast<const void*>(&opdata3)), nullptr, 0, },
};
#endif

used_operators_e used_ops[] =
{OP_FULLY_CONNECTED, OP_FULLY_CONNECTED, OP_FULLY_CONNECTED, OP_SOFTMAX, };



static void init_tflite_tensor(size_t i, TfLiteTensor *tensor) {
  tensor->type = kTfLiteFloat32;
  tensor->is_variable = 0;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  tensor->allocation_type = tensorData[i].allocation_type;
#else
  tensor->allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
  tensor->bytes = tensorData[i].bytes;
  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  if(tensor->allocation_type == kTfLiteArenaRw){
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
      tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
  tensor->quantization.type = kTfLiteNoQuantization;

}

static void init_tflite_eval_tensor(int i, TfLiteEvalTensor *tensor) {

  tensor->type = kTfLiteFloat32;

  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  auto allocation_type = tensorData[i].allocation_type;
  if(allocation_type == kTfLiteArenaRw) {
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
    tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
}

static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBufferImpl(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  uint32_t align_bytes = (bytes % 16) ? 16 - (bytes % 16) : 0;

  if (current_location - (bytes + align_bytes) < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  // align to the left aligned boundary of 16 bytes
  current_location -= 15; // for alignment
  current_location += 16 - ((uintptr_t)(current_location) & 15);

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}
typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;
static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArenaImpl(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBufferImpl(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBufferImpl(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static const uint16_t TENSOR_IX_UNUSED = 0x7FFF;

static void ResetTensors() {
  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    tflTensors[ix].index = TENSOR_IX_UNUSED;
  }
  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    tflEvalTensors[ix].index = TENSOR_IX_UNUSED;
  }
}

static TfLiteTensor* GetTensorImpl(const struct TfLiteContext* context,
                               int tensor_idx) {

  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    // already used? OK!
    if (tflTensors[ix].index == tensor_idx) {
      return &tflTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_tensor(tensor_idx, &tflTensors[ix].tensor);
      tflTensors[ix].index = tensor_idx;
      return &tflTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_TENSOR_COUNT (%d)\n", MAX_TFL_TENSOR_COUNT);
  return nullptr;
}

static TfLiteEvalTensor* GetEvalTensorImpl(const struct TfLiteContext* context,
                                       int tensor_idx) {

  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    // already used? OK!
    if (tflEvalTensors[ix].index == tensor_idx) {
      return &tflEvalTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflEvalTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_eval_tensor(tensor_idx, &tflEvalTensors[ix].tensor);
      tflEvalTensors[ix].index = tensor_idx;
      return &tflEvalTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_EVAL_COUNT (%d)\n", (int)MAX_TFL_EVAL_COUNT);
  return nullptr;
}

class EonMicroContext : public MicroContext {
 public:
  EonMicroContext(): MicroContext(nullptr, nullptr, nullptr) { }

  void* AllocatePersistentBuffer(size_t bytes) {
    return AllocatePersistentBufferImpl(nullptr, bytes);
  };
  TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                           int* buffer_index) {
  return RequestScratchBufferInArenaImpl(nullptr, bytes, buffer_index);
  }
  void* GetScratchBuffer(int buffer_index) {
    return GetScratchBufferImpl(nullptr, buffer_index);
  }

  TfLiteTensor* AllocateTempTfLiteTensor(int tensor_index) {
    return GetTensorImpl(nullptr, tensor_index);
  }
  void DeallocateTempTfLiteTensor(TfLiteTensor* tensor) {
    return;
  }
  bool IsAllTempTfLiteTensorDeallocated() {
    return true;
  }

  TfLiteEvalTensor* GetEvalTensor(int tensor_index) {
    return GetEvalTensorImpl(nullptr, tensor_index);
  }
};

} // namespace

TfLiteStatus tflite_learn_7_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;

  EonMicroContext micro_context_;
  ctx.impl_ = static_cast<void*>(&micro_context_);
  ctx.AllocatePersistentBuffer = &AllocatePersistentBufferImpl;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArenaImpl;
  ctx.GetScratchBuffer = &GetScratchBufferImpl;
  ctx.GetTensor = &GetTensorImpl;
  ctx.GetEvalTensor = &GetEvalTensorImpl;
  ctx.ReportError = &MicroContextReportOpError;
  ctx.tensors_size = 11;
  for (size_t i = 0; i < 11; ++i) {
    TfLiteTensor tensor;
    init_tflite_tensor(i, &tensor);
    if (tensor.allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tensor.data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }
  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }
  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t i = 0; i < 4; ++i) {
if (registrations[used_ops[i]].init) {
       tflNodes[i].user_data = registrations[used_ops[i]].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
    }
  }
  for (size_t i = 0; i < 4; ++i) {
    if (registrations[used_ops[i]].prepare) {
      ResetTensors();

      TfLiteStatus status = registrations[used_ops[i]].prepare(&ctx, &tflNodes[i]);
      if (status != kTfLiteOk) {
        return status;
      }
    }
  }
  return kTfLiteOk;
}

static const int inTensorIndices[] = {
  0, 
};
TfLiteStatus tflite_learn_7_input(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(inTensorIndices[index], tensor);
  return kTfLiteOk;
}

static const int outTensorIndices[] = {
  10, 
};
TfLiteStatus tflite_learn_7_output(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(outTensorIndices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_7_invoke() {
  for (size_t i = 0; i < 4; ++i) {
    ResetTensors();

    TfLiteStatus status = registrations[used_ops[i]].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_7_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
